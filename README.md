# Checkers
#### Video Demo: <https://youtu.be/N4aBTsVBGos>
## Description:
This project is a **web based real time two-players checker game**.It is implemented using **Flask** for backend, **sqlite** for database, and some **bootstrap** for style in the front end. **For real time game movement it uses flask socketio. This game is turn based, capture enforced game**.

Most of the front end logic and the board are in the room.html file. I have used table for the board, and I have assigned them an id 1-64. I have put the black pieces in the first 24 cells and the green in the last 24 cells. If the move was ±14 or ±18 it means it may be valid jump and client side has also to send the piece information in the middle that are ±7 or ±9. However, doing that can cause error. The reason is if the element that is moving is lets say with id 63 and trying to get the middle element which its id is 63+7 or 63+ 9 and such ids are non existential in the program. To fix this I have used low bound and high bound variables that stores the ids that produce invalid ids when added or subtracted by 7 or 9. 

New players have to register using a username and password. Passwords has to meet certain criteria. They have to be strong enough that are hard to guess. For this purpose I have used **password validator** liabrary. Once a player is registered, they are sent to the server by post method. The reason for that is **password and sensetive info should not be seen in the browser's search bar. The password is hashed and are added to the database**. The reason it is hashed is if an attackers attack the database they don't see the real password, instead they see a hashed password. After registering players can log in using their password and username.

Once players log in **session** is tracked, then they can either start a game or join a game. A player clicks the start game button a random code is generated, his friend joins with code. Upon joining they are put into a room.The player that starts the game is given black pieces and the one joined is given green pieces. And they are stored in the session with color as key. i used this design to **monitor who is making the move, which player is allowed to move which pieces, where the player is allowed to move his pieces and soon**. It uses global dictionaries to track and monitor games, where each room number acts as a unique key. **This structure prevents changes made in one room from affecting the state of any other room. Once the game is over the key associated with the room is deleted to save memory or prevent memory leak**. Moreover, **Eventlet** is used to handle concurrency. In layout.html which is the parent of all my html files I have added css that specifically targets larger screen like laptops. The reason I did this was The board and pieces looked way too small in laptops compared to phones.

All the logic for the game is in game_logic.py file. A move made by a player is emitted to server with all the datas and server evaluates the move, and send response back to frontend. To manage turn, server tracks the current player's session upon valid move so he/she waits for the other player to make his/her move. The only time the prevous player allowed to make move is if his/her move was capture and there is leftover. Since the server does not know whether the player has leftover,it gives the player few seconds to capture his/her leftover. Once the player capture an oppenent piece it is appended or added to his/her list of captures. Anyone that has captured 12 pieces is the winner because it means all the oppenents pieces are captured. I have used "None" when appending the players' list. **The reason I did that is the data type is irrelevant and memory space matters. "None" is the most memory efficient**.

When players join a room they are assigned a copy of global dictionary "board" to track the state of the board. **I didn't assign it directly instead I copied it because if it was assigned directly the original board would change everytime a player make a move in any room and wouldn't work as intended**. The global board must be in its intial state always. The changes must only reflect in the room's board. Everytime a player makes a valid move the board (that was assigned to the room) is updated. When a player does not make a capture, the force_capture function is called. The force capture loops through the whole board and checks if there is piece that must be captured by the player.

### Potential For Improvements
1. Using **class** instead of functions for the game logics. This would have been more readable and organized. I wouldn't have to pass the arguments/ parameters for every function.

2. Using **Redis** would be more scalable than dictionary. When deploying the app using gunicorn, it wouldn't work using more than one worker. Even if the players are in one room they could be accessing different memory. When you have many users and only one worker, the program would be slow.

## Attribution
I have used sound effects from Zapslat.


